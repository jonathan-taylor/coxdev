% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coxdev.R
\name{make_cox_irls_state}
\alias{make_cox_irls_state}
\title{Create IRLS state for Cox model coordinate descent}
\usage{
make_cox_irls_state(cox_obj)
}
\arguments{
\item{cox_obj}{A Cox deviance object created by \code{make_cox_deviance} or
\code{make_stratified_cox_deviance}}
}
\value{
A list with methods for IRLS/coordinate descent:
\itemize{
\item \code{recompute_outer(eta, weights)}: Recompute all cached quantities (call once per outer IRLS)
\item \code{working_weights()}: Get cached working weights
\item \code{working_response()}: Get cached working response
\item \code{residuals()}: Get cached residuals r = w * (z - eta)
\item \code{current_deviance()}: Get deviance from last recompute_outer
\item \code{weighted_inner_product(x_j)}: Returns c(gradient_j, hessian_jj)
\item \code{update_residuals(delta, x_j)}: Update r -= delta * w * x_j
\item \code{reset_residuals(eta)}: Reset residuals for new CD pass
}
}
\description{
Creates a stateful object that caches expensive quantities (exp(eta), risk sums,
working weights/response) computed once per outer IRLS iteration, enabling
efficient coordinate descent.
}
\examples{
# Simple coordinate descent example
set.seed(42)
n <- 100; p <- 5
X <- matrix(rnorm(n * p), n, p)
beta_true <- c(1, -0.5, 0.3, 0, 0)
eta_true <- X \%*\% beta_true
time <- rexp(n, exp(eta_true))
status <- rbinom(n, 1, 0.7)

# Create Cox deviance and IRLS state
cox <- make_cox_deviance(event = time, status = status)
irls <- make_cox_irls_state(cox)

# Initialize
beta <- rep(0, p)
eta <- X \%*\% beta
weights <- rep(1, n)

# Outer IRLS iteration
irls$recompute_outer(eta, weights)
cat("Initial deviance:", irls$current_deviance(), "\n")

# Inner coordinate descent pass
for (j in 1:p) {
  x_j <- X[, j]
  gh <- irls$weighted_inner_product(x_j)
  delta <- gh["gradient"] / gh["hessian"]
  beta[j] <- beta[j] + delta
  irls$update_residuals(delta, x_j)
}
eta <- X \%*\% beta
irls$recompute_outer(eta, weights)
cat("After 1 CD pass:", irls$current_deviance(), "\n")
}
